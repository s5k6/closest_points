#!/usr/bin/python

import random
import math
import sys


class Point:
    def __init__(self, *coords):
        self.coords = coords

    def dist(p1, p2):
        return math.sqrt(sum(map(
            lambda u, v: (u - v) ** 2,
            p1.coords,
            p2.coords
        )))

    def __str__(self):
        return '[' + ','.join(map(str, self.coords)) + ']'

def mkPoints(n, d=5):

    points = list()
    d = random.randrange(1, 7)
    for i in range(n):
        cs = map(lambda _: random.randrange(math.floor(10*n/d)), range(d))
        points.append(Point(*cs))
    print('Generated {} points in {} dimensions.'.format(len(points), d))

    return points



def bruteForce(points):
    '''Brute force implementation.  O(**2)'''

    p = points[0]
    q = points[1]
    d = Point.dist(p, q)

    for p2 in points:
        for q2 in points:
            if p2 is q2:
                continue
            d2 = Point.dist(p2, q2)
            if d2 < d:
                d = d2
                p = p2
                q = q2
    return d, p, q



def closestPair(points):
    '''https://en.wikipedia.org/wiki/Closest_pair_of_points_problem

    This implementation relies on Python's list sections being
    generators.

    '''

    # recursive divide and conquer part
    def recurse(ps):
        l = len(ps)

        # there's no pair
        if l < 2:
            return math.inf, None, None

        # there's exactly one pair
        if l == 2:
            p = ps[0]
            q = ps[1]
            return Point.dist(p, q), p, q

        # split list in two, recurse left and right, `(d, p, q)` is
        # the minimum over both results wrt. `d`.
        s = l // 2
        left = ps[:s]
        right = ps[s:]
        d, p, q = min(
            recurse(left),
            recurse(right),
            key = lambda a: a[0] # 1st entry of tuple is distance
        )

        # Now check whether any point on the left is closer to any
        # point on the right then `d`.

        # how far to look into the left points (from right end)
        leftmost = right[0].coords[0] - d
        for l in reversed(left):
            # for each point on left which is close enough...
            if l.coords[0] < leftmost:
                break
            # ...check out the first few on the right side.
            rightmost = l.coords[0] + d
            for r in right:
                if r.coords[0] > rightmost:
                    break
                # test for new minimum
                d2 = Point.dist(l, r)
                if d2 < d:
                    d = d2
                    p = l
                    q = r

        return d, p, q

    # start recursion on points sorted wrt. 1st coordinate
    return recurse(sorted(points, key = lambda p: p.coords[0]))



def closestPair2(unsortedPoints):
    '''https://en.wikipedia.org/wiki/Closest_pair_of_points_problem

    Version using list indexing.  This would be more like a C
    implementation.

    '''

    points = sorted(unsortedPoints, key = lambda p: p.coords[0])

    def recurse(i, j): # first, last+1

        if j - i < 2:
            return math.inf, None, None

        if j - i == 2:
            p = points[i]
            q = points[i+1]
            return Point.dist(p, q), p, q

        s = (i + j) // 2
        d, p, q = min(
            recurse(i, s),
            recurse(s, j),
            key = lambda a: a[0] # 1st entry of tuple is distance
        )

        leftmost = points[s].coords[0] - d
        for l in reversed(points[i:s]):
            if l.coords[0] < leftmost:
                break
            rightmost = l.coords[0] + d
            for r in points[s:j]:
                if r.coords[0] > rightmost:
                    break
                d2 = Point.dist(l, r)
                if d2 < d:
                    d = d2
                    p = l
                    q = r

        return d, p, q


    return recurse(0, len(points))



def run(fun, points):
    '''Run one algorithm, and print its result.  Returns smallest
    distance found.

    '''
    d, p, q = fun(points)
    print('{}: {} {} {}'.format(fun.__name__, d, p, q))
    return d

def compare(points):
    '''Runs all algorithms and compares their results.  Returns
    consensus.

    '''
    ds = list(map((lambda a: run(a, points)), [
        bruteForce,
        closestPair,
        closestPair2
    ]))
    ret = all(x == ds[0] for x in ds[1:])
    if ret:
        print('[32mGood[m')
    else:
        print('[31mMismatch[m')
    return ret


def main(argv):
    '''Repeatedly runs all known algorithms on sets of random points.

    If the results differ, the point set is written to disk for
    inspection.

    '''

    if len(argv) > 0:
        ret = 0
        for fn in argv:
            points = []
            try:
                with open(fn, 'tr') as fh:
                    for line in fh:
                        points.append(Point(*map(int, line.split(' '))))
                    print('Loaded {} points from {}.'.format(len(points), fn))

            except FileNotFoundError:
                print('Failed to read: {}'.format(fn))
                ret = 1
                continue

            except ValueError:
                print('Invalid format: {}'.format(fn))
                ret = 1
                continue

            if not compare(points):
                ret = 1

        return ret

    else:

        fnum = 0
        while True:
            points = mkPoints(random.randrange(1000) + 2)

            if not compare(points):
                while True:
                    try:
                        with open('failed{:05}.txt'.format(fnum), 'tx') as fh:
                            for p in points:
                                fh.write(' '.join(map(str, p.coords)) + '\n')
                    except FileExistsError:
                        fnum += 1
                        continue
                    break

    return 0


if __name__ == '__main__':
    try:
        exit(main(sys.argv[1:]))
    except KeyboardInterrupt:
        print('KeyboardInterrupt')
        exit(1)
